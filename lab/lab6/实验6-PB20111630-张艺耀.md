# 计算机组成原理 **实验报告**

> 姓名：张艺耀
>
> 学号：PB20111630 
>
> 实验日期：2022- 5 - 11
> 
## 实验题目

综合设计

## 实验目的

•理解计算机硬件系统的组成结构和工作原理

•掌握软硬件综合系统的设计和调试方法


## 实验平台

FPGAOL  

Vivado

Mac + VSCode-remote + SSH + VLab

## 实验过程

### Part.1 补充指令至37条

除去Lab5流水线的6条指令外，又添加了31条指令，使得指令总数为37条。

添加的指令如下：

```verilog
//supplementary
wire is_lui;    //Load Upper Immediate x[rd] = sext(imm[31:12] << 12)
wire is_auipc;  //Add Upper Immediate to PC x[rd] = pc + sext(imm[31:12] << 12)
wire is_jalr;   //Jump and Link Register t = pc + 4; pc = (x[rs1] + sext(offset))&~1; x[rd] = t;
wire is_bne;    
wire is_blt;
wire is_bge;
wire is_bltu;
wire is_bgeu;
wire is_lb; //load byte
wire is_lh; //load halfword
wire is_lbu; //load byte, unsigned
wire is_lhu; //load halfword, unsinged
wire is_sb; //store byte
wire is_sh; //store halfword
wire is_slti;   //Set if Less Than Immediate
wire is_sltiu;
wire is_xori;
wire is_ori;
wire is_andi;
wire is_slli;
wire is_srli;
wire is_srai;
wire is_sub;
wire is_sll;
wire is_slt;
wire is_sltu;
wire is_xor;
wire is_srl;
wire is_sra;
wire is_or;
wire is_and;
```

由于半字和字节的读写指令需要在数据存储器内部进行操作，故将原有的IP核删去，自行实现`data_mem`

#### Addition of controller.v

```verilog

//supplementary
assign is_lui = (opcode == 7'h37);
assign is_auipc = (opcode == 7'h17);
assign is_jalr = (opcode == 7'h67) && (funct3 == 3'h0);
assign is_bne = (opcode == 7'h63) && (funct3 == 3'h1);
assign is_blt = (opcode == 7'h63) && (funct3 == 3'h4);
assign is_bge = (opcode == 7'h63) && (funct3 == 3'h5);
assign is_bltu = (opcode == 7'h63) && (funct3 == 3'h6);
assign is_bgeu = (opcode == 7'h63) && (funct3 == 3'h7);
assign is_lb = (opcode == 7'h03) && (funct3 == 3'h0);
assign is_lh = (opcode == 7'h03) && (funct3 == 3'h1);
assign is_lbu = (opcode == 7'h03) && (funct3 == 3'h4);
assign is_lhu = (opcode == 7'h03) && (funct3 == 3'h5);
assign is_sb = (opcode == 7'h23) && (funct3 == 3'h0);
assign is_sh = (opcode == 7'h23) && (funct3 == 3'h1);
assign is_slti = (opcode == 7'h13) && (funct3 == 3'h2);
assign is_sltiu = (opcode == 7'h13) && (funct3 == 3'h3);
assign is_xori = (opcode == 7'h13) && (funct3 == 3'h4);
assign is_ori = (opcode == 7'h13) && (funct3 == 3'h6);
assign is_andi = (opcode == 7'h13) && (funct3 == 3'h7);
assign is_slli = (opcode == 7'h13) && (funct3 == 3'h1) && (funct7 == 7'h00);
assign is_srli = (opcode == 7'h13) && (funct3 == 3'h5) && (funct7 == 7'h00);
assign is_srai = (opcode == 7'h13) && (funct3 == 3'h5) && (funct7 == 7'h20);
assign is_sll = (opcode == 7'h33) && (funct3 == 3'h1) && (funct7 == 7'h00);
assign is_slt = (opcode == 7'h33) && (funct3 == 3'h2) && (funct7 == 7'h00);
assign is_sltu = (opcode == 7'h33) && (funct3 == 3'h3) && (funct7 == 7'h00);
assign is_xor = (opcode == 7'h33) && (funct3 == 3'h4) && (funct7 == 7'h00);
assign is_srl = (opcode == 7'h33) && (funct3 == 3'h5) && (funct7 == 7'h00);
assign is_sra = (opcode == 7'h33) && (funct3 == 3'h5) && (funct7 == 7'h20);
assign is_or = (opcode == 7'h33) && (funct3 == 3'h6) && (funct7 == 7'h00);
assign is_and = (opcode == 7'h33) && (funct3 == 3'h7) && (funct7 == 7'h00);

...
always@(*) begin
    if(is_add_type) alu_ctrl = 4'h1;
    else if(is_sub) alu_ctrl = 4'h2;
    else if(is_lui) alu_ctrl = 4'h3;
    else if(is_slt | is_slti) alu_ctrl = 4'h4;
    else if(is_sltu | is_sltiu) alu_ctrl = 4'h5;
    else if(is_xor | is_xori) alu_ctrl = 4'h6;
    else if(is_or | is_ori) alu_ctrl = 4'h7;
    else if(is_and | is_andi) alu_ctrl = 4'h8;
    else if(is_sll | is_slli) alu_ctrl = 4'h9;
    else if(is_srl | is_srli) alu_ctrl = 4'ha;
    else if(is_sra | is_srai) alu_ctrl = 4'hb;
    else    alu_ctrl = 4'h0;
end
...

always@(*) begin
    if(is_lw) dm_rd_ctrl = 3'b1;
    else if(is_lhu) dm_rd_ctrl = 3'h2;
    else if(is_lh) dm_rd_ctrl = 3'h3;
    else if(is_lbu) dm_rd_ctrl = 3'h4;
    else if(is_lb) dm_rd_ctrl = 3'h5;
    else dm_rd_ctrl = 3'b0;
end

always@(*) begin
    if(is_sw) dm_wr_ctrl = 2'b1;
    else if(is_sh) dm_wr_ctrl = 2'h2;
    else if(is_sb) dm_wr_ctrl = 2'h3;
    else dm_wr_ctrl = 2'b0;
end

always@(*) begin
    if(opcode == 7'h3) rf_wr_sel = 2'h3;
    else if(((~ is_jalr) & is_i_type) | is_u_type | is_r_type) rf_wr_sel = 2'h2;
    else if(is_jal | is_jalr) rf_wr_sel = 2'h1;
    else rf_wr_sel = 2'h0;
end

```

#### Change of data_mem.v

```verilog
module data_mem (
    input [9:0]a,   //read and write (dm_addr)
    input [31:0]d,  //write data
    input [7:0]dpra,    //read only (im_addr)
    input clk,
    input [1:0] we, //dm_wr_ctrl
    output reg [31:0]spo,   //mem[a]
    output [31:0]dpo,   //mem[dpra]
    //supplementary
    input [2:0] dm_rd_ctrl
);
reg [3:0] byte_en;
reg [31:0] mem[0:255];
reg [31:0] mem_out;
integer i;

initial begin
    for(i = 0; i < 255; i = i + 1) mem[i] = 0;
end

initial begin
    $readmemh("/home/ubuntu/文档/Code/COD/lab6/coe/data.coe",mem);
end

assign dpo = mem[dpra];

always@(*) begin
    case(a[1:0])
    2'b00: mem_out = mem[a[9:2]][31:0];
    2'b01: mem_out = {8'h0, mem[a[9:2]][31:8]};
    2'b10: mem_out = {16'h0, mem[a[9:2]][31:16]};
    2'b11: mem_out = {24'h0, mem[a[9:2]][31:24]};
    default: mem_out = 0;
    endcase
end

always@(*) begin
    case(dm_rd_ctrl)
    3'h1: spo = mem_out;    //is_lw
    3'h2: spo = {16'h0, mem_out[15:0]}; //is_lhu
    3'h3: spo = {{16{mem_out[15]}}, mem_out[15:0]}; //is_lh
    3'h4: spo = {24'h0, mem_out[7:0]};  //is_lbu
    3'h5: spo = {{24{mem_out[7]}}, mem_out[7:0]};   //is_lb
    default: spo = 32'h0;
    endcase
end

always@(*) begin
    if(we == 2'b1) byte_en = 4'b1111;
    else if(we == 2'b10) begin
        if(a[1] == 1'b1) byte_en = 4'b1100;
        else byte_en = 4'b0011;
    end
    else if(we == 2'b11) begin
        case(a[1:0])
        2'b00: byte_en = 4'b1;
        2'b01: byte_en = 4'b10;
        2'b10: byte_en = 4'b100;
        2'b11: byte_en = 4'b1000;
        default: byte_en = 4'b0;
        endcase
    end
    else byte_en = 0;
end

module data_mem (
    input [9:0]a,   //read and write (dm_addr)
    input [31:0]d,  //write data
    input [7:0]dpra,    //read only (im_addr)
    input clk,
    input [1:0] we, //dm_wr_ctrl
    output reg [31:0]spo,   //mem[a]
    output [31:0]dpo,   //mem[dpra]
    //supplementary
    input [2:0] dm_rd_ctrl
);
reg [3:0] byte_en;
reg [31:0] mem[0:255];
reg [31:0] mem_out;
integer i;

initial begin
    for(i = 0; i < 255; i = i + 1) mem[i] = 0;
end

initial begin
    $readmemh("/home/ubuntu/文档/Code/COD/lab6/coe/data.coe",mem);
end

assign dpo = mem[dpra];

always@(*) begin
    case(a[1:0])
    2'b00: mem_out = mem[a[9:2]][31:0];
    2'b01: mem_out = {8'h0, mem[a[9:2]][31:8]};
    2'b10: mem_out = {16'h0, mem[a[9:2]][31:16]};
    2'b11: mem_out = {24'h0, mem[a[9:2]][31:24]};
    default: mem_out = 0;
    endcase
end

always@(*) begin
    case(dm_rd_ctrl)
    3'h1: spo = mem_out;    //is_lw
    3'h2: spo = {16'h0, mem_out[15:0]}; //is_lhu
    3'h3: spo = {{16{mem_out[15]}}, mem_out[15:0]}; //is_lh
    3'h4: spo = {24'h0, mem_out[7:0]};  //is_lbu
    3'h5: spo = {{24{mem_out[7]}}, mem_out[7:0]};   //is_lb
    default: spo = 32'h0;
    endcase
end

always@(*) begin
    if(we == 2'b1) byte_en = 4'b1111;
    else if(we == 2'b10) begin
        if(a[1] == 1'b1) byte_en = 4'b1100;
        else byte_en = 4'b0011;
    end
    else if(we == 2'b11) begin
        case(a[1:0])
        2'b00: byte_en = 4'b1;
        2'b01: byte_en = 4'b10;
        2'b10: byte_en = 4'b100;
        2'b11: byte_en = 4'b1000;
        default: byte_en = 4'b0;
        endcase
    end
    else byte_en = 0;
end

always@ (posedge clk) begin
    if(byte_en != 0) begin
        if(byte_en == 4'b1111) mem[a[9:2]] <= d;
        else if(byte_en == 4'b0011) mem[a[9:2]] <= {mem[a[9:2]][31:16], d[15:0]};
        else if(byte_en == 4'b1100) mem[a[9:2]] <= {d[15:0], mem[a[9:2]][15:0]};
        else if(byte_en == 4'b0001) mem[a[9:2]] <= {mem[a[9:2]][31:8], d[7:0]};
        else if(byte_en == 4'b0010) mem[a[9:2]] <= {mem[a[9:2]][31:16], d[7:0], mem[a[9:2]][7:0]};
        else if(byte_en == 4'b0100) mem[a[9:2]] <= {mem[a[9:2]][31:24], d[7:0], mem[a[9:2]][15:0]};
        else if(byte_en == 4'b1000) mem[a[9:2]] <= {d[7:0], mem[a[9:2]][23:0]};
        else mem[a[9:2]] <= d;
    end
end

endmodule

```

#### Change of br.v

```verilog
module br(
    input [31:0] a,
    input [31:0] b,
    input [2:0] comp_ctrl,
    input do_branch,
    input do_jump,
    output branch
);
wire signed [31:0] signed_a;
wire signed [31:0] signed_b;
wire [31:0] unsigned_a;
wire [31:0] unsigned_b;
reg taken;

assign signed_a = a;
assign signed_b = b;
assign unsigned_a = a;
assign unsigned_b = b;

always@(*) begin
    case(comp_ctrl)
    3'h0: taken = (signed_a == signed_b);
    3'h1: taken = ~(signed_a == signed_b);
    3'h2: taken = 1'b0;
    3'h3: taken = 1'b0;
    3'h4: taken = (signed_a < signed_b);
    3'h5: taken = (signed_a >= signed_b);
    3'h6: taken = (unsigned_a < unsigned_b);
    3'h7: taken = (unsigned_a >= unsigned_b);
    default: taken = 0;
    endcase
end

assign branch = (taken && do_branch) || do_jump;

endmodule
```

#### Bug fixed and change of lab5

```verilog
//cpu_pl.v Bug fixed 将IDEXrf_rd1改为IDEXrd_rd1_fd
EXMEM EXMEM(clk, alu_out, IDEXrf_rd1_fd, IDEXRd, IDEXpc, IDEXrf_wr_en, IDEXdm_rd_ctrl, IDEXdm_wr_ctrl, IDEXrf_wr_sel, EXMEMalu_out, EXMEMrf_rd1, EXMEMRd, EXMEMpc, EXMEMrf_wr_en, EXMEMdm_rd_ctrl, EXMEMdm_wr_ctrl, EXMEMrf_wr_sel);

...
//change
data_mem data_mem(.a (EXMEMalu_out[9:2]), .d (EXMEMrf_rd1), .dpra (m_rf_addr), .clk (clk), .we (dm_wr_ctrl_aft), .spo (dm_dout), .dpo (m_data));
```


```verilog
//program_counter.v Bug fixed 解决了fStall后pcin仍加4的bug
...
always@(*) begin
    if(br) pcin <= alu_out;
    else if(PCWrite) pcin <= pc_plus4;
    else pcin <= pc;
end
...
```

#### 测试代码 my_final_test.asm

```assembly
.data
out: .word 0x00
in: .word 0x00

.text
lui x6,0xf #lui
auipc x7, 0xf #auipc

la x10, jalrtest
jalr x10 #jalr
addi x5, x0, 0x1

jalrtest:
addi x10, x0, 0xf
addi x11, x0, 0xa

bne x10, x11, bnetest #bne
addi x5, x0, 0x1

bnetest:
addi x10, x0, 0xa
addi x11, x0, 0xf

blt x10, x11, blttest #blt
addi x5, x0, 0x1

blttest:
addi x10, x0, 0xf
addi x11, x0, 0xa

bge x10, x11, bgetest #bge
addi x5, x0, 0x1

bgetest:
addi x10, x0, 0xff
addi x11, x0, 0xffffffff

bltu x10, x11, bltutest #bltu
addi x5, x0, 0x1

bltutest:
addi x10, x0, 0xffffffff
addi x11, x0, 0xff

bgeu x10, x11, bgeutest #bgeu
addi x5, x0, 0x1

bgeutest:
slti x5, x10, 0	#slti
addi x5, x0, 0
sltiu x5, x10, 0 #sltiu
addi x11, x0, 0xf

xori x10, x11, 0xa #xori
ori x10, x11, 0xf0 #ori
andi x10, x11, 0xa #andi
slli x10, x11, 0x1 #slli
addi x12, x0, 0xffffffff
srli x10, x12, 0x1 #srli
srai x10, x12, 0x1 #srai
sub x10, x12, x11 #sub
slt x10, x12, x11 #slt
sltu x10, x12, x11 #sltu
addi x10, x0, 0xf
addi x11, x0, 0xa
xor x10, x10, x11 #xor
addi x11, x0, 1
srl x10, x12, x11 #srl
sra x10, x12, x11 #sra
or x10, x12, x11 #or
and x10, x12, x11 #and

la x10, out
li x11, 0xff
sw x11, (x10)
li x11, 0xffff
sw x11, 4(x10)
lb x6, (x10) #lb
lh x6, 4(x10) #lh
lbu x6, (x10) #lbu
lhu x6, 4(x10) #lhu
sb x6, 8(x10) #sb
sh x6, 8(x10) #sh
```

#### 仿真测试

所有寄存器变化（均与Rars中的结果一致）：

![image-20220514153018612](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220514153018612.png)

![image-20220514153101004](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220514153101004.png)

![image-20220514153139223](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220514153139223.png)

![image-20220514153159854](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220514153159854.png)

半字和字节的读写（data_mem的变化）：

![image-20220514153232580](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220514153232580.png)

### Part.2 基于BTB(Branch Target Buffer)的动态分支预测

由于ins_data大小为256x32，pc可选取的值较少，故无需对pc使用哈希映射，直接使用32位宽的数组buffer存储预测的pc`reg [31:0] pred_pc [0: 1 << 6]`。

BTB原理如下：

<img src="/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220515202428707.png" alt="image-20220515202428707" style="zoom:45%;" />

BTB模块介于IF ID段寄存器之间，对于IF段寄存器输出的PCF输入到BTB中，BTB查找buffer，如果命中则向PC模块输入地址，PC模块选择预测PC作为下一个PC，如果不命中则直接使用PC+4作为下一个PC。命中的状态位（1表示预测跳转，0表示不预测跳转）和预测PC也随流水段到达EX阶段。

等到当前指令到达了EX阶段，就可以确定当前指令是否跳转，如果**实际跳转但之前未预测跳转**或者**实际不跳转但之前预测跳转**，都需要清空ID和EX段寄存器（hazard_detection模块置dFlush和eFlush为1），PC模块重新生成下一个PC。在实际跳转但之前未预测跳转的情况下，需要把当前PC和跳转PC更新写入到BTB的buffer中。在实际不跳转但之前预测跳转的情况下，需要把BTB的buffer中的对应项有效位置0。

#### BTB.v

```verilog
module BTB(
    input clk, rst,
    input [31:0] rd_pc,    //输入pc
    output reg rd_pred,           //预测信号
    output reg [31:0] rd_pred_pc,  //从buffer中得到的预测pc
    
    input wr_req,   //写请求信号
    input [31:0] wr_pc, //要写入的分支pc
    input [31:0] wr_pred_pc,    //要写入的预测pc
    input wr_pred_state_bit //预测状态位
);

//ins_mem为256x32，故pc有效位是[9:2]
reg [31:0] pred_pc [0: 1 << 6];
reg pred_state_bit [0: 1 << 6];
integer i;

always@(*) begin
    if(pred_state_bit[rd_pc[9:2]]) rd_pred = 1'b1;
    else rd_pred = 1'b0;
    rd_pred_pc = pred_pc[rd_pc[9:2]];
end

always@(posedge clk or posedge rst) begin
    if(rst) begin
        for(i = 0; i < 1 << 6; i = i + 1) begin
            pred_pc[i] <= 0;
            pred_state_bit[i] <= 1'b0;
        end
        rd_pred <= 0;
        rd_pred_pc <= 0;
    end else begin 
        if(wr_req) begin
            pred_pc[wr_pc[9:2]] <= wr_pred_pc;
            pred_state_bit[wr_pc[9:2]] <= wr_pred_state_bit;
        end
    end
end

endmodule
```

#### Change of hazard_detection.v

```verilog
module hazard_detection(
    input [2:0] IDEXdm_rd_ctrl,
    input [4:0] IDEXRd,
    input [4:0] IFIDRs1,
    input [4:0] IFIDRs2,
    output PCWrite,
    output IFIDWrite,
    output stallpl,

    //br_pred
    input branch,
    input br_pred_e,
    input jump,
    output dFlush, eFlush
);

assign PCWrite = (IDEXdm_rd_ctrl && ((IDEXRd == IFIDRs1) || (IDEXRd == IFIDRs2))) ? 1'b0 : 1'b1;
assign IFIDWrite = (IDEXdm_rd_ctrl && ((IDEXRd == IFIDRs1) || (IDEXRd == IFIDRs2))) ? 1'b0 : 1'b1;
assign stallpl = (IDEXdm_rd_ctrl && ((IDEXRd == IFIDRs1) || (IDEXRd == IFIDRs2))) ? 1'b1 : 1'b0;
assign dFlush = ((branch ^ br_pred_e) || jump) ? 1'b1 : 1'b0;
assign eFlush = ((branch ^ br_pred_e) || jump) ? 1'b1 : 1'b0;

endmodule
```

#### Change of cpu_pl.v

```verilog
//cpu_pl.v
...

wire branch;
wire jump;
wire br_pred_f; //IF
wire br_pred_d; //ID
wire br_pred_e; //EX
wire [31:0] br_pred_pc_f;

...

hazard_detection hazard_detection(IDEXdm_rd_ctrl, IDEXRd, IFIDinst[19:15], IFIDinst[24:20], PCWrite, IFIDWrite, stallpl, branch, br_pred_e, jump, dFlush, eFlush);

...

program_counter program_counter(
    clk, 
    rst, 
    branch, 
    br_pred_e, 
    br_pred_f,
    br_pred_pc_f,
    jump,
    alu_out,
    PCWrite,
    pc,
    pcin,
    pc_plus4
);

IFID IFID(clk, pc_in, inst, IFIDWrite, IFIDpc, IFIDinst, dFlush, br_pred_f, br_pred_d);

register_file register_file(.clk (clk), .rst (rst), .ra0 (IFIDinst[19:15]), .ra1 (IFIDinst[24:20]), .ra2 (m_rf_addr[4:0]), .wa (MEMWBRd), .wd (rf_wd), .we (MEMWBrf_wr_en), .rd0 (rf_rd0), .rd1 (rf_rd1), .rd2 (rf_data));

imm imm(.inst (IFIDinst), .imm_out (imm_out));

controller controller(IFIDinst, rf_wr_en, alu_a_sel, alu_b_sel, alu_ctrl, dm_rd_ctrl, dm_wr_ctrl, rf_wr_sel, comp_ctrl, do_branch, do_jump);

IDEX IDEX(clk, IFIDpc, IFIDinst[11:7], imm_out, rf_rd0, rf_rd1, rf_wr_en_hd, alu_a_sel, alu_b_sel, alu_ctrl, dm_rd_ctrl, dm_wr_ctrl_hd, rf_wr_sel, comp_ctrl, do_branch, do_jump, IDEXpc, 
IDEXRd, IDEXImm, IDEXrf_rd0, IDEXrf_rd1, IDEXrf_wr_en, IDEXalu_a_sel, IDEXalu_b_sel, IDEXalu_ctrl, IDEXdm_rd_ctrl, IDEXdm_wr_ctrl, IDEXrf_wr_sel, IDEXcomp_ctrl, IDEXdo_branch, IDEXdo_jump, 
IFIDinst[19:15], IFIDinst[24:20], eFlush, IDEXRs1, IDEXRs2, br_pred_d, br_pred_e);

alu alu(alu_a, alu_b, IDEXalu_ctrl, alu_out);

br br(.a (IDEXrf_rd0_fd), .b (IDEXrf_rd1_fd), .comp_ctrl (IDEXcomp_ctrl), .do_branch (IDEXdo_branch), .do_jump (IDEXdo_jump), .branch (branch), .jump (jump));

EXMEM EXMEM(clk, alu_out, IDEXrf_rd1_fd, IDEXRd, IDEXpc, IDEXrf_wr_en, IDEXdm_rd_ctrl, IDEXdm_wr_ctrl, IDEXrf_wr_sel, EXMEMalu_out, EXMEMrf_rd1, EXMEMRd, EXMEMpc, EXMEMrf_wr_en, EXMEMdm_rd_ctrl, EXMEMdm_wr_ctrl, EXMEMrf_wr_sel);

ins_mem ins_mem(.a (pc_in[9:2]), .spo (inst));

data_mem data_mem(.a (EXMEMalu_out[9:0]), .d (EXMEMrf_rd1), .dpra (m_rf_addr), .clk (clk), .we (dm_wr_ctrl_aft), .spo (dm_dout), .dpo (m_data), .dm_rd_ctrl (EXMEMdm_rd_ctrl));

MEMWB MEMWB(clk, EXMEMrf_wr_en, EXMEMrf_wr_sel, dm_dout_aft, EXMEMalu_out, EXMEMRd, EXMEMpc, MEMWBrf_wr_en, MEMWBrf_wr_sel, MEMWBdm_dout, MEMWBalu_out, MEMWBRd, MEMWBpc);

//branch prediction
BTB BTB(.clk (clk),
        .rst (rst),
        .rd_pc (pc),
        .rd_pred_pc (br_pred_pc_f),
        .rd_pred (br_pred_f),
        .wr_req (br_pred_e ^ branch),
        .wr_pc (pce),
        .wr_pred_pc (alu_out),
        .wr_pred_state_bit(branch)
);

...
```

#### Change of PC.v

```verilog
module program_counter(
    input clk,
    input rst,
    input br,

    //branch prediction signals
    input br_pred_e,
    input br_pred_f,
    input [31:0] br_pred_pc,
    input jump,

    input [31:0] alu_out,
    input PCWrite,

    output reg [31:0] pc,
    output reg [31:0] pcin,
    output [31:0] pc_plus4
);


always@(*) begin
    if(jump) pcin <= alu_out;
    else if(br && ~br_pred_e) pcin <= alu_out;  //预测不跳转但实际跳转
    else if(~br && br_pred_e) pcin <= pc_plus4; //预测跳转但实际不跳转
    else if(br_pred_f) pcin <= br_pred_pc;    
    else if(!PCWrite) pcin <= pc;  //idk if branch prediction has conflict with data hazard
    else pcin <= pc_plus4;
end

always@(posedge clk or posedge rst) begin
    if(rst) pc <= 32'h3000;
    else pc <= pcin;
end

assign pc_plus4 = pc + 32'h4;

endmodule
```

#### 把br_pred信号通过流水段寄存器运送到EX段

```verilog
//IFID.v
...
br_pred_d <= br_pred_f;
...
```

```verilog
//IDEX.v
...
br_pred_e <= br_pred_d;
...
```

#### 测试代码

```assembly
.text
addi x10, x0, 10
addi x11, x0, 1
branch:
sub x10, x10, x11
bge x10, x0, branch
```

#### 仿真结果

`br_pred_f = 1`触发预测  `pcin`直接被置为`0x3008`

![image-20220515204556972](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220515204556972.png)

循环结束时 触发`(br_pred_e && ~br)`预测跳转但实际不跳转 把pcin置为当前pc + 4，同时在BTB中更改相应`status_bit`

![image-20220515204940659](/Users/fluegelcat/Library/Application Support/typora-user-images/image-20220515204940659.png)

## 实验结果

见实验过程。

## 心得体会

